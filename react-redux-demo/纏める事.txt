纏めること


・reactそのもの
  ★★★完了★★★
  １）基本のコンセプト　react公式のreactの流儀のやつがいいかな？
    →jsx(htmlとの違い…イベントの属性名、条件付きrender)、props、props.children、state(setStateするときはstate用いるならコールバック)とか、
    →関数コンポーネントとクラスコンポーネント、
    →条件付きレンダリング
    →ライフサイクルメソッド
    →イベント処理
    →map()におけるkey
    →制御されたフォーム

  ★★★完了★★★
  ２）高度なコンセプト(個別に作成)
    →fragment
    →lazy(() => import())、suspence、error boundary
    →context
    →ref(とDOM)
    →高階コンポーネント


★★★完了★★★
・イミュータブルなstate更新のやつ

★★★完了★★★
・router
  →router使ってページ分けするようにしたい　switchも

★★★完了★★★
・reduxとかの状態管理方法
  →とりあえずqiitaのやつ纏める
  →reducer複数のやつ
  →fetchのやつ付ける

★★★完了★★★
・materialuiとか

★★★完了★★★
・スタイルの書き方ベスト
　シンプルなreactアプリであればcssをそのまま書いてcssモジュールとする
　materialuiではmakestyles()かな

★★★完了★★★
ツールキット
  ▶reducerのstateがネストしてる時に書き方楽に寝るみたい
  ▶他にもstoreのセットアップが楽になったりする
  configureStore,createSlice,createAsyncThunk,createEntityAdapterとある
  ツールキットはとりあえずこんな感じでとらえておけばおｋ
・re-ducksパターン
　オペレーション、セレクタ―
　→副作用(非同期処理とか)含むactionがオペレーション、stateのどれ読み出すか選択がセレクターみたいな感じ
　→dispatchとstate読出しに相当する？

★★あとはコメント書いておくだけのもの
・reduxのstoreでrouteを管理？？
　connected-react-routerつかったらできた。ただしver.4じゃないと挙動おかしい(笑)
・コンテナのcompose
　引数に渡された複数の関数を右から左に順に合成する
　渡される関数は各々一つだけ引数を受取ることができ
　その戻り値は左の関数の引数となる

★未完(ここからredux公式の件
・actionのタイプ命名しっかり
　→アプリの主な機能として追跡したいstateを定義して初期stateを設計
　　initialState = {todos: {...}, filters: {...}}
　→stateの各プロパティについてのactionを設計する
　　{type: "TODOS/TODOADDED", payload: todoText}
　　{type: "FILTERS/FILTER_CHANGED", payload: filter}
　　typeは "'stateのプロパティ'/'具体的なアクション名'"とする
　→各actionに対するreducerを設計する
　　function todosReducer(state, action){}
　　function filtersReducer(state, action){}
　　関数名は'stateのプロパティ'+Reducerとなる
　　これらreducerはstore.jsとかでcombineされる
　→selectorを設計する(必要に応じて？createSelector見て考える)
　　関数名はselect+'選択したいstate'　かな


・selectorに関してshallowEqualとReact.memo()とreselectのcreateSelector
・todolistitem keyの所わからん
・標準的なreduxのパターン(storeには配列使わないでオブジェクトとか・・・)
・storeのメソッドまとめ？
　getState(), dispatch(action), subscribe(listener), unsubscribe※subscribeの戻り値
・react redux 各フック
　useState,
　useCallback,
　useEffect
　　→クラスコンポーネントのcomponentDidmount,componentWillunmountとかの処理を関数コンポーネントで使える上に一気にかける
　useDispatch
　　→reactコンポーネント内でstore.dispatchが使えるようにする
　useSelector
　　→reactコンポーネント内でstoreの値を選択して取り出すとともに、store.subscribeみたいなことをしてくれる
　　　…actionがdispatchされる度にselectorを呼出し、結果が前回と異なれば該当コンポーネントの再レンダリング
　　　を行うが、、、厳密な比較演算===なのでdispatch時、値は同じでも新しい配列とかになると前回と違う参照として判定してしまう
　　　これの対策として他のコンポーネントから変更される可能性のあるstateは直接selectorで読み取らずに
　　　そのstateのプロパティにID等のプリミティブ型を持たせ、それを読み取り、コンポーネント内で使用すれば、値のみの比較なので問題ない
　　　しかしそれでもどこかで該当のオブジェクトや配列を読み出さなければならない事が多いと思うので
　　　useSelector()の第二引数にshallowEqualをわたしてやると、オブジェクトや配列の中の値を比較するようになる。
　　　createSelectorについては
　　　　dispatchがあるたびに無駄な再レンダリングはshallowEqualで防げるが、インラインでuseselectorに
　　　　渡す関数を書いているとき、selector関数の再計算は行われしまう。再計算を防ぎ、なおかつ再レンダリングをも防ぐもの

・とりあえずそんなに大規模なもの作らないのでducksパターンで
　stateフォルダつくってstoreとかいれてそのままducksパターンでそのフォルダ内に作る
・view関係は共通要素のcomponentsとページ呼出し単位のpagesくらいの分け方で
　componentsの中身はatomicデザインのざっくりした感じ。
　pagesの中身はcomponentsのつなぎ合わせとpage固有の要素
・assetsとかは？
　スタイルは基本cssインポートと、materialUiならmakestyleでいいけど
　assetsにいれるスタイルは共通のスタイル入れる？
　imgは基本importでいいはず。publicフォルダはfaviconとか？？

・firebase