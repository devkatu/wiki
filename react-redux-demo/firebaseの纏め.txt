・firebase導入方法ざっくり
　・ダッシュボードでの作業
　　firebaseコンソール(ダッシュボードみたいなの)からプロジェクトを作成する
　　ダッシュボードからreact等のウェブアプリに対して作成したfirebaseプロジェクトを追加する
　　プロジェクトの設定からリソースロケーションを設定する
　　　asia-northeast1のリージョンにしておく
　　databaseについて本番環境で開始を行う。
　・コンソールからの作業
　　・npm install -g firebase-tools
　　　これをインストールするとfirebaseのCLIが使えるようになる
　　・npm install -s firebase
　　　アプリでfirebaseを使うならこれをインストールしておく
　　　firebaseをimportしてstorageやらdatabaseやらが使えるよになる
　　・アプリのディレクトリから firebase login を行い作成したプロジェクトにログインする
　　・firebase init で初期化を行う
　　　使用サービスをスペースキーで選択する。firestoreとかfunctionsとかhostingとかstorageとか選べる
　　　使用するプロジェクトを選択する。既存のプロジェクトや新規プロジェクトとか選べる
　　　hostingの選択ではbuildディレクトリを選択しておく
　　　あとはほとんどデフォルト
　　・npm run build してから firebase deploy をするとhostやらrulesなんやらがfirebaseへデプロイされる
　　　この後はアプリ作ればbuildしてdeploy、rules変えたりしてもdeployする必要あり。
　　・firebase deployについて
　　　以下ルールのみデプロイするオプションあり
　　　--only hosting
　　　--only database
　　　--only storage
　　　--only firestore
　　　--only firestore:rules
　　　--only firestore:indexes
　　　--only functions

・firebaseをinitすると
　・functionsフォルダ
　　サーバー側での処理を記述するファイル。
　・firestore.rulesとかsotorage.rulesとかについて
　　firestoreやstorageとかのパーミッションを設定するファイル。
　　変更したらfirebase deployする必要がある。

・firebaseを使いやすいようにするために自分で作るもの
　・src>firebase>config.js
　　firebaseの設定を行うファイル。APIkeyとか入ってる。
　　firebaseコンソールの設定→Firebase SDK Snippet→構成から丸コピーしてこのファイルに張り付けている。
　・src>firebase>index.js
　　上のconfig.jsを読込んでinitislizeApp(firebaseConfig)したり
　　使用するFirebaseサービスを読込んで使いやすくエクスポートしてあげたりする

・auth(firebase.auth)について
　・まずはコンソールから、signin方法を選択して有効にする。
　　動画ではこの後にconfig.jsへ設定コピーしていたがいつでもいいと思う
　auth.createUserWithEmailAndPassword(email, password).then(result => {})
　　→メールアドレスとパスワードでユーザーアカウントを作成する。resultにはuser情報とかが入っているオブジェクトが入る
　　作成に成功したら、dbにもresult.user.uidをidとするドキュメントを登録するとよい。
　auth.signInWithEmailAndPassword(email, password).then(result => {})
　　→メールアドレスとパスワードでログインする。resultにはuser情報とかが入っているオブジェクトが入る
　auth.signOut().then(() => {})
　　→ログアウトを行う。
　auth.onAuthStateChanged(user => {})
　　→現在のログイン状態を確認できる。userにはユーザー情報が入りuser.uidがユーザーIDとなる。
　　このrulesでのresource.auth.uidとかと一緒
  

・db(firebase.firestore)のメソッド色々
　db.collection('todos').orderBy('timestamp', 'asc').get()
　　→firestore上のtodosコレクションからtimestampのフィールドについて、
　　ascなら昇順、descなら降順でドキュメントを取得する
　await db.collection('todos').doc(id).set(initTodo).catch(e => { throw new Error(e) });
　　→firestore上のtodosコレクションのid指定したドキュメントにinitTodoを登録する
　db.collection('todos').doc(id).update(sendTodo)
　　→firestore上のtodosコレクションのid指定したドキュメントにsendTodoを更新する
　db.collection('todos').doc(id).delete()
　　→firestore上のtodosコレクションのid指定したドキュメントを削除する
　db.collection('todos').onSnapshot(snapshots => {
    snapshots.docChagnges().forEach(change=>{
        const data = change.doc.data();
        const changeType = change.type;
        // added, modified, removedの値をとる
    })
　})
　　→firestore上のtodosコレクションの変化をリッスンする事ができるようになる
　　changeTypeの値を用いて処理を分岐する。db上の値が確実に変更された事が分かるので
　　db上の値を変更する処理の後、storeを更新したりするときはコレが良いかも
　　dbにset()とかを投げて.then()とかでも同じかもだけど
　　このonsnapshotの戻り値にはリスナー登録の解除関数が入っているみたいなので
　　コンポーネントのマウント解除時に呼出すようにすること。
　　コンポーネント呼出すたびにコールバック登録されちゃう

・dbのルール
　firestore.rulesにdbへのオペレーションを制御するルールを記述できる
　基本的にはデフォルト状態では全てのドキュメントへのオペレーションはfalseで
　許可するオペレーションを一つ一つ条件付きで許可する形で書く。
　書き方はfirestore.rulesにコメント書いてあるので参照。
　更新したら firebase deploy --only firestore:rules でデプロイすること
　新しいコレクションを追加したときには忘れずに。。

・dbの設計しっかりとやるのが大事
　→reduxのように！DBで保存したい項目(コレクション)をリストアップして予めしっかり設計しておくこと
　例えば
    category
    product
    user
        cart
        orders  みたいな。エクセルとかで書いておくといいかも

・storageのメソッド色々
　const uploadTask = storage.ref('images').child(fileName).put(blob);
　uploadTask.then( () => {
    uploadTasksnapshot.ref.getDownloadURL().then((downloadURL) => {

    })
})
　→以下のメソッドでstorage上の/imagesディレクトリに、blob化したファイルを、fileNameという名前でアップロードして
　そのアップロードしたファイルのダウンロード用URLを取得できる


★未完



〇ここはどんな感じに作るかざっくり書いておきたい
・トラハックyoutube実践編で作成していた主な機能まとめ　
　商品管理
　  追加/編集
        ProductEditコンポーネントが呼ばれるとき、
        window.location.pathname.split('/product/edit')[1]に値が入るときには
        それを商品IDと判断してコンポーネントの変数として保存し、
        useEffectにてidが存在すれば既存データの編集として、該当のproductsコレクションからデータを読み込み、
        コンポーネント単体のステートとして保存しておく。データ読み込みはstoreを更新するわけではないので
        オペレーションではなく、コンポーネント側にてuseEffect内に処理を記述している。
        idが存在しない場合はこれらをせずに新規データ登録画面として働く。
        また、この編集データを保存する時には、新規作成でも既存データ編集でも同じオペレーション関数を使うが、
        idが存在しなければ、オペレーション側で新しいidを採番し、dbに保存する作りになっている。
    一覧
        ProductListコンポーネントが呼ばれるとき
        window.location.search変数をチェックして?gender=や?category=等のクエリが入っていれば
        productコレクションにそれらのフィルターを適用したクエリを投げ、なければすべての
        productコレクションを要求する。 
    削除
        productList => productCard => MenuIcon と呼ばれるなかで商品IDがpropsとして渡されてくるので
        そのprops.idをdeleteするオペレーション関数に渡すだけ。

    　★編集の項目あたりでurlから商品IDを取得してうんぬんやってた
    　　routeの方も正規表現あったりもするのでそれも
        window.location.pathname.split('/detail')[1]  動画のuseEffectで編集するのやつ
        →クエリパラーメタで商品を表示するイメージではなく、普通に商品詳細URLを入力する感じで
        　表示したいならこっち。windowオブジェクトはreactでなくても使えるグローバルオブジェクトなので
        　自分で今のpathnameを取得してばらしてやるイメージ
        props.match.params.id.split('/detail')[1]
        →react-router使ってるならこれでもいいかも。Routeコンポーネントで設定したpath属性に
        　detail/:idとしておくとprops.match.params.idで取得できる
        　上記二つはRouterコンポーネントはpath="/detail/:id"でexact付きでもOK

        selector.router.location.search.split('?id=')[1]    動画の複合クエリのやつ
        →クエリパラメータがあるときはこっち。reduxのstoreに入ってるのでselectorで指定して取得してやる。
        　(connected-react-routerを使っていればstoreに入っているはず)
        　location.pathnameでもとれるけどこっちには直接クエリパラメータが入っているので多少楽かも
        　Routeコンポーネントはpath="/detail"でexact付きでもOK
        　exact付けてもクエリまではみていないみたい
        window.location.searchでも取得できると思う
        →クエリパラメータが複数あるときは上の方法では無理かも？？こっちなら？？

　カート機能
　　追加/削除/知覧
　注文履歴
　　追加/一覧
　検索
　　性別/カテゴリ



決済の方法
