# Git

## 初期化
```
$ git init
```

## ワークツリーとインデックスの状態を確認
```
$ git status
```

## 変更をインデックスに登録する(ステージ)
file指定してステージ
```
$ git add <file>
```

全部のファイルをステージ
```
$ git add .
```

## ステージされた変更のコミット
```
$ gif commit -m "コメント"
```

## リポジトリの変更履歴
```
$ git log
```
GUIで確認したいときは
```
$ gitk
```

## ブランチの作成
```
$ git branch <ブランチ名>
```

## ブランチ一覧の表示
```
$ git branch
```

## ブランチの切替
```
$ git chekout <ブランチ名>
```

## ブランチの統合
- masterから派生したトピックブランチ等でのみコミットが進んでいた場合で、masterへ変更を取り込むなら、
  masterをチェックアウトした後、
  ```
  $ git merge <ブランチ名>
  ```
  この場合はfirst-fowardマージとなる。(HEADの位置が進むだけ)
- masterとtopic等のブランチでそれぞれコミットが進んでしまった場合、masterへ変更を取り込むなら、
  masterをチェックアウトした後、
  ```
  $ git merge <ブランチ名>
  ```
  コンフリクトが起き、自動マージに失敗した場合、コンフリクトの起きたファイルの該当箇所以下のようになる
  ```
  <<<<<<< HEAD
  【現在のブランチの内容】
  =======
  【merge使用としたブランチの内容】
  >>>>>>> issue
  ```
  これを修正した後、改めて、ステージ＞コミットすることで、新規にコミット(マージコミット)が作成される
- masterとtopic等のブランチでそれぞれコミットが進んでしまった場合で、変更履歴を複雑にしたく無い、直線的にしたい場合は
  masterではなく、トピック等のブランチをチェックアウトした後、
  ```
  $ git rebase <masterブランチ>
  ```
  コンフリクトが起きたら、ファイルが先のと同様に差分が差込まれるので、修正する。
  修正したら、
  ```
  $ git rebase --continue
  ```
  これでmasterからfast-forwardマージ可能になる。masterをチェックアウトし、
  ```
  $ git merge <masterブランチ>
  ```

## ブランチの削除
```
$ git branch -d <ブランチ名>
```

## リモートリポジトリの追加
nameにはoriginを付けるのが慣例。pushやpullもリポジトリを省略するとoriginを使用する。
リモートのURLは対象のサービス上で確認する。
```
$ git remote add <name> <リモートのURL>
```

## プッシュ
```
$ git push <リモートのURL> <プッシュするローカルブランチ>...
```

## プル
現在のブランチにリモートのブランチを取り込む
```
$ git pull <リモートのURL> <プルするリモートブランチ>...
```

## フェッチ
リモートの最新履歴を取得する。名前のないブランチとして(FETCH_HEADとしてチェックアウトもできる)取得するだけで、これをマージすることもできる。フェッチ＋マージがプルとなる。
```
$ git fetch <リモートのURL> <フェッチするリモートブランチ>...
```

## クローン
```
$ git clone <リモートのURL> <複製先ディレクトリ>
```

## コミットタイミング・コミットメッセージについて

タイミングとしては、

| タイミング                   | 理由                   |
| ----------------------- | -------------------- |
| ✅ **動く状態になった時**         | バグが出てもすぐ戻せるようにするため   |
| ✅ **大きな単位の変更を終えた時**     | 「何をしたか」が後で追いやすい      |
| ✅ **依存パッケージやSDKを更新した時** | 将来のトラブル時にバージョンを追跡できる |
| ✅ **リリース前 / 後**         | 区切りを明確にするため          |

メッセージはプリフィックスとして下記を付け、その後に概要を付けると見やすいかも

| 種類            | 意味             |
| ------------- | -------------- |
| **feat:**     | 新機能追加          |
| **fix:**      | バグ修正           |
| **chore:**    | 環境設定・ビルド設定など   |
| **refactor:** | 構造改善（挙動は同じ）    |
| **docs:**     | ドキュメント修正       |
| **style:**    | 見た目やフォーマット変更のみ |
| **test:**     | テスト追加や修正       |
| **wip:**      | 作業中(Work In Progreess) コミット増えるけどsquashすると纏められる|

## 応用コマンド


### 1\. git stash（一時避難）

\*\*「作業中だけど、急に別の作業を頼まれた！でも中途半端だからコミットしたくない」\*\*という時に使います。

- **役割:** 変更内容を一時的に「机の引き出し」に隠すイメージ。
- **主なコマンド:**
    - `git stash`: 現在の変更を一時保存して、作業場を綺麗にする。
    - `git stash pop`: 隠していた変更を元に戻す。

* * *

### 2\. git restore（ファイル単位の復旧）

\*\*「ファイルをいじりすぎてグチャグチャになったから、最後にコミットした時の状態に戻したい」\*\*という時に使います。

- **役割:** 特定のファイルの内容を、過去のコミットやステージングの状態に戻す「消しゴム」。
- **主なコマンド:**
    - `git restore <ファイル名>`: 作業ディレクトリの変更を取り消す。
    - `git restore --staged <ファイル名>`: `git add` したのを取り消す（アンステージ）。

* * *

### 3\. git reset vs git revert（歴史の書き換え vs 打ち消し）

ここが一番の混乱ポイントです。どちらも「過去に戻る」系ですが、やり方が違います。

| **コマンド** | **特徴** | **使う場面** |
| --- | --- | --- |
| **reset** | 歴史を**なかったこと**にする。 | 自分一人の作業中で、コミットを完全に消したい時。 |
| **revert** | 打ち消すための**新しいコミット**を作る。 | すでに共有した（Pushした）歴史を安全に消したい時。 |

#### git reset のイメージ

「時間を巻き戻す」イメージです。

- `--soft`: コミットだけ消して、中身（コード）は残す。
- `--hard`: コミットもコードも全て指定した時点まで巻き戻す。**（注意：未コミットのコードは消えます！）**

#### git revert のイメージ

「反対の動作を上書きする」イメージです。

「昨日のコミット（A）を打ち消す、コミット（A'）」を新しく作るので、全体の歴史が壊れません。

* * *

### 4\. git reflog（最後の砦）

\*\*「間違えて reset --hard しちゃった！コミットが消えた！」\*\*という絶望的な状況で使います。

- **役割:** HEAD（自分の現在地）が通った全ての履歴を記録している「防犯カメラの映像」。
- **使い方:**
    - `git reflog` を打つと、過去の全ての動きが表示されます。
    - そこから消してしまったコミットのID（ハッシュ）を見つけて、`git reset --hard <ID>` で救出できます。

> **豆知識:** Gitにおいて、一度でもコミットしたものは `reflog` がある限り、ほぼ確実に救出可能です。

* * *

### まとめ：どう使い分ける？

- **ちょっと作業を横に置きたい:** `stash`
- **ファイルの変更を元に戻したい:** `restore`
- **自分だけの世界でコミットをやり直したい:** `reset`
- **みんなと共有している歴史を安全に戻したい:** `revert`
- **やらかした！魔法で過去に戻りたい:** `reflog` でIDを探して `reset`