# javascriptの実践的知識

## async,awaitについて
---
attention: 　async function を呼出したときpromiseオブジェクトが返されるはずだが
　何も値をreturnしないときはどういう挙動に？
　また呼び出し側でawaitとか.thenしないときは？

## null,undefined
---
- undefined(未定義)はjavascriptのみに存在するプリミティブ型であり、グローバルオブジェクトのプロパティ  
var a; みたいに宣言だけして初期化していない変数は自動的にundefined型となり、値はundefinedが割り当てられる。  
尚、windowのグローバル変数であり違うスコープ作って変数undefinedをまた宣言できたりするので注意
- nullは変数に意図的に代入して、"何も入っていない"ことを表すものでこれはオブジェクト型である


## 配列、オブジェクトの空かどうかチェックする方法
---
配列、オブジェクトに対する処理の前に対象が空っぽかどうかチェックする方法
```javascript
// 配列は長さをチェック
if(arr.length !== 0){
  // 配列長さが0でないなら実行
}

// オブジェクトはプロパティの有無をチェック
if(Object.keys(obj).length !== 0){
  // オブジェクトプロパティが0でなければ実行
}
```

## objectのconsole.log
---
objectをそのままconsole.logするとネストが深かったりすると表示しきれず、変数の型によっては  
[object Object]みたいな感じになって見ることができない。  
JSONのメソッドで文字列化してあげるといい感じにみることができる。  

```javascript
var obj = {
  a: "a",
  b: {
    c: "C",
    d: {
      e: "aaa",
      f: {
        abc: 1
      }
    }
  }
}
console.log(obj)
// {a: "a", b:{...}}

console.log(JSON.stringify(obj, null, 2))
// 上の形で全て表示される。引数の3つ目はインデントとなる
```

## 配列のメソッドあれこれ
---
結構わかりづらい配列メソッドまとめ。<br>
破壊的、非破壊的とあるので注意！
```javascript
// 破壊的メソッド
  // (fruitsの中身が変わって、戻り値に取り出したものや配列の長さがくる)
  // 元の配列に変更を加えたくない場合は
  // let temp = arr.slice() したり
  // let temp = [...arr] スプレッド構文で切り出して
  // 切り出した配列に対して処理をおこなう

  fruits.push('みかん') // 配列の末尾に "みかん" を追加
  // ["りんご", "バナナ", "みかん"]
  fruits.pop() // 配列の末尾の要素 "みかん" を削除
  // ["りんご", "バナナ"]
  fruits.shift() // 配列の先頭の要素"りんご" を削除
  // ["バナナ"]
  fruits.unshift('いちご') // 配列の先頭に追加
  // ["いちご", "バナナ"]
  fruits.splice(1, 1) // 要素を指定して削除　引数は添え字、削除個数
  // ["いちご", "マンゴー"]

// 非破壊的メソッド
  // mapは配列の各要素に色々手を加えてから新しい配列を返したいとき
  // 引数のコールバック関数の一個目の引数はイテレートした各要素、
  // 二個目の引数はその要素のindexとなり
  // 戻り値が新しい配列の各要素となる。
  // 例)ある配列をもとに新しいオブジェクトの配列を返す
  let newLists = trainingContentsLists.map((content, index) => {
    return { label: content, value: content }
  })
  
  // filterは配列の各要素の中から、条件に合う要素を選択して、新しい配列を返したいとき
  // 引数のコールバック関数の一個目の引数はイテレートした各要素、
  // 二個目の引数はその要素のindexとなり、
  // 戻り値が新しい配列の各要素となる。なにも戻り値を返さなければその要素は除外される。
  // 例)menuesオブジェクト配列から各オブジェクトのnameプロパティが
  // 　trainingNameである要素を選択して新しい配列として返す
  matchTraining = menues.filter(menu => {
    if (trainingName === menu.name) return menu;
  })
  
  // reduceは配列の各要素に対して、順に累積したような処理を行いたいとき
  // 引数のコールバック関数の一個目の引数は累積していく値で、
  // 二個目の引数は各要素をイテレートしていって取り出される値、
  // 戻り値が次のイテレートで一個目の引数に入る値となる。
  // 例)menuesオブジェクト配列から各オブジェクトのweightプロパティを比較し
  // 　大きいものを順次返していく。最終的にはオブジェクト配列の中でweightが最大のものを返す
  max = menues.reduce((accMenu, curMenu) => {
    // accMenu 累積していく値。このコールバックでreturnした値が次のイテレートでaccMenuに入る
    // curMenu イテレートで順次取り出される値
    if (accMenu.weight < curMenu.weight) {
      return curMenu;
    } else {
      return accMenu;
    }
  })

  // foreachは配列の中身に対して色々な処理を行いたいとき(返り値はundefined)
  // 例)上の三つのメソッドは配列を返すが配列を返さなくていい時や
  // 　上三つでは満たされないとき(map,reduceで各配列編集したいけど特定の要素は要らないとか)
  // 　はこのforeachをつかっておこなう。
  // 　foreachに渡すコールバックはmap、reduceのような形式となるが返り値はundefinedとなる。
  // 　コールバックの中で処理を行って、新しい配列をpushしていったりする使い方となる。
  ```

## 連続した数字の配列生成
---
inputのselect等に使う連続した数値の生成方法
```javascript
// 以下のいずれも同じ感じ

const miniutes = Array.from(new Array(60)).map((v,i) => i)
// 空っぽの配列60個作って、そのインデックスを数値に持つ配列をmapでつくって
// その浅いコピーをfromで作る。最後のfromなくてもよさそうだけどないとダメ

const minitues = [...Array(60).keys()]
// 60の長さの配列のkeyをスプレッドで展開して、リテラルで新しい配列をつくる
```

## 数値input関係の簡単なバリデート
---
入力フォームに数値のみを受け付けたい時の簡単なバリデーション。  
例としてreactnativeでなんらかのイベントでstate更新するときのものをあげている。
webでも同じ考え方でok
```javascript
<Input
  onChangeText={(value)=>{
    // ⇒目的の型にparseしてみてNaNならなにも入力させず、NaNでないときだけ受け付ける
    isNaN(parseInt(value)) ? setState("") : setState(parseInt(value))

    // 目的の型がfloatだとsetState(parseFloat(value))すると小数点以下消えるので
    // setState(value)にしたい、、、が判定がisNaN(parseFloat(value))だと
    // parseは解釈できるところまでparseしちゃうので(1.10.1とかは1.1になる)
    isNaN(value) ? (なにもしないかvalueが空っぽなら空をset) : setState(value)
  }}
>
```