<!DOCTYPE HTML>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>クロージャとonclick</title>
  <style type="text/css">
  </style>
</head>
<body>

  <h3>クロージャとonclick</h3>
  <ul id="z01" >
    <li><a href="#">0</a></li><!-- 4 -->
    <li><a href="#">1</a></li><!-- 4 -->
    <li><a href="#">2</a></li><!-- 4 -->
    <li><a href="#">3</a></li><!-- 4 -->
  </ul>

  <script type="text/javascript">

  // クロージャについて
  window.onload=function(){
    var element = document.getElementById("z01").getElementsByTagName("li");
    for(var i=0;i<element.length;i+=1){
      add_the_handlers(element);
    }
  }
  /*
  // 誤り。これはクロージャになっておらず、onclickメソッドはfor文終了後のi…4にアクセスしてしまう
  // for文ループ時の変数iのコピーを渡せるようなクロージャとする必要がある。
  // オブジェクトとにている。。。
  var add_the_handlers = function (nodes) {
  var i;
  for (i = 0; i < nodes.length; i += 1) {
  nodes[i].onclick = function (e) {
  alert(i);
};
}
};
*/

//パターン1
// onclickに代入される即時関数にadd_the_handlers関数で定義した
// 変数iを渡す(コピー)事でこの即時関数でのローカル変数となり
// ハンドラとして返される内部の関数はその外部のiにアクセスすることになる
var add_the_handlers = function (nodes) {
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    nodes[i].onclick = (function (i) {
      return function (e) {
        alert(i);  //ここがイベントハンドラとなる。
      };
    })(i);  //即時関数を定義してその場で変数iを渡し実行している
  }
};

//パターン2
// パターン1の即時関数をhelperというデリゲートに代入して実行するパターン
var add_the_handlers = function (nodes) {
  var helper = function (i) {
    return function (e) {
      alert(i);
    };
  };
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    nodes[i].onclick = helper(i);
  }
};

//パターン3
// javascriptでオセロのやつで使ってたパターン
// パターン1を変形し、ローカル変数jを新たに定義し、変数iを代入、
// onclickメソッドはこのjが記憶されるのでここにアクセスする。
var add_the_handlers = function (nodes) {
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    (function(){
      var j=i;
      nodes[i].onclick = function (e) {
        alert(j);
      };
    }());
  }
};

//パターン4
// 1,3を合わせたような形。パターン3のような新たにローカル変数を
// 作らずに引数にiを渡して即時関数を実行し、コピーを渡している
var add_the_handlers = function (nodes) {
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    (function(i){
      nodes[i].onclick = function (e) {
        alert(i);
      };
    }(i));
  }
};


// 変数のスコープと巻き上げ
// javascriptの変数スコープは基本的には他言語と同じくスコープチェーン(ある変数を参照するとき
// 自分のブロックで定義されているか確認し、なければその親のブロックへと続く)であるが、
// ifやfor文の時のブロックスコープが無く、 関数ブロックでのみスコープのみが分かれる。
// 加えて内部の関数の途中で定義した変数はその関数内の全てで有効となり一行上のcosole.logでは
// 未定義となり出力不可となる。これを変数の巻き上げといい、関数内で使用する変数は関数の
// 最初に定義しておくとよい
(function(){
  var val = "global";
  (function(){
    console.log(val);  //変数の巻き上げが起こりvalの値は未定義となる
    var val = "local";  //ここをコメントかすると上のconsole.logはglobalになる
    console.log(val);
  })();
  console.log(val);
})();

</script>
</body>
</html>
